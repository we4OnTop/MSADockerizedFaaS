worker_processes 1;

events {
    worker_connections 10240;
}

http {
    lua_shared_dict gate_config 1m;

    log_format latency_log '[$time_local] "$request" Status:$status '
                           'TotalTime:$request_time BackendTime:$upstream_response_time '
                           'QueueTime:$sent_http_x_queue_latency';

    access_log /dev/stdout latency_log;

    init_by_lua_block {
        local semaphore = require("ngx.semaphore")
        require("cjson")
        global_gate_sem = semaphore.new()
        global_wait_count = 0
    }

    server {
        listen 80;

        # 1. Config Update (bleibt gleich, speichert jetzt "BLOCK:/test")
        location /admin/config {
            content_by_lua_block {
                local cjson = require("cjson")
                local shared = ngx.shared.gate_config
                ngx.req.read_body()
                local body_data = ngx.req.get_body_data()
                if not body_data then return end
                local conf = cjson.decode(body_data)
                shared:flush_all()
                if conf.blocked then
                    for _, path in ipairs(conf.blocked) do
                        -- Speichert z.B. "BLOCK:/test"
                        shared:set("BLOCK:" .. path, true)
                    end
                end
                if global_wait_count > 0 then
                    global_gate_sem:post(global_wait_count)
                end
                ngx.say("Config updated.")
            }
        }

        # 2. Traffic Gate (angepasst für führende Slashes)
        location / {
            set $queue_latency "0";

            access_by_lua_block {
                local shared = ngx.shared.gate_config
                local uri = ngx.var.uri

                -- ÄNDERUNG: ^(/[^?]*)
                -- Das Klammernpaar umschließt jetzt AUCH den Slash.
                -- Aus "/test" wird "/test" (vorher war es "test").
                local path_segment = uri:match("^(/[^?]*)")

                -- Fallback für Root, falls nötig (bei "/" liefert der Regex aber eh "/")
                if not path_segment or path_segment == "" then
                    path_segment = "/"
                end

                local start_time = ngx.now()

                while true do
                    -- Jetzt suchen wir nach "BLOCK:/test" -> Das passt zum Input!
                    local is_blocked = shared:get("BLOCK:" .. path_segment)
                    if not is_blocked then break end

                    global_wait_count = global_wait_count + 1
                    local ok, err = global_gate_sem:wait(60)
                    global_wait_count = global_wait_count - 1

                    if not ok then ngx.exit(ngx.HTTP_GATEWAY_TIMEOUT) end
                end

                local end_time = ngx.now()
                local queue_duration = end_time - start_time

                ngx.var.queue_latency = string.format("%.99f", queue_duration)
                ngx.header["X-Queue-Latency"] = ngx.var.queue_latency
            }

            proxy_pass http://backend;
        }

        # 3. List Blocked Routes (Fixes applied)
        location /admin/list {
            content_by_lua_block {
                local cjson = require("cjson")
                local shared = ngx.shared.gate_config

                local keys = shared:get_keys(1024)
                local blocked_list = {}

                for _, key in ipairs(keys) do
                    -- ÄNDERUNG: (.*) nimmt alles nach dem Doppelpunkt, auch den Slash.
                    local path = key:match("^BLOCK:(.*)")
                    if path then
                        table.insert(blocked_list, path)
                    end
                end

                ngx.header.content_type = "application/json"
                ngx.say(cjson.encode({
                    blocked = blocked_list,
                    -- ÄNDERUNG: #blocked_list gibt die Anzahl als Zahl zurück
                    count = #blocked_list
                }))
            }
        }
    }
}