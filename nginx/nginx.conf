worker_processes 1;

events {
    worker_connections 10240;
}

http {
    lua_shared_dict gate_config 1m;

    log_format latency_log '[$time_local] "$request" Status:$status '
                           'TotalTime:$request_time BackendTime:$upstream_response_time '
                           'QueueTime:$sent_http_x_queue_latency';

    access_log /dev/stdout latency_log;

    resolver 127.0.0.11 ipv6=off;

    init_by_lua_block {
        local semaphore = require("ngx.semaphore")
        require("cjson")
        global_gate_sem = semaphore.new()
        global_wait_count = 0

        require("resty.http")
    }

    server {
        listen 99;

        location /admin/config {
                    content_by_lua_block {
                        local cjson = require("cjson")
                        local shared = ngx.shared.gate_config
                        ngx.req.read_body()
                        local body_data = ngx.req.get_body_data()
                        if not body_data then return end
                        local conf = cjson.decode(body_data)
                        shared:flush_all()
                        if conf.blocked then
                            for _, path in ipairs(conf.blocked) do
                                -- Speichert z.B. "BLOCK:/test"
                                shared:set("BLOCK:" .. path, true)
                            end
                        end
                        if global_wait_count > 0 then
                            global_gate_sem:post(global_wait_count)
                        end
                        ngx.say("Config updated.")
                    }
        }
    }

    server {
        listen 80;

        location / {
            set $queue_latency "0";

            access_by_lua_block {
                local shared = ngx.shared.gate_config
                local uri = ngx.var.uri
                local path_segment = uri:match("^(/[^?]*)") or "/"

                local start_time = ngx.now()
                local init_is_blocked = shared:get("BLOCK:" .. path_segment)

                -- Falls blockiert, senden wir den Increment-Request an Redis-Rest-Pusher
                if init_is_blocked then
                    local http = require "resty.http"
                    local cjson = require "cjson"
                    local httpc = http.new()

                    local res, err = httpc:request_uri("http://redis-rest-pusher:7071/pushFAASIncrement", {
                        method = "POST",
                        body = cjson.encode({ ["function-name"] = path_segment }),
                        headers = { ["Content-Type"] = "application/json" }
                    })

                    -- WICHTIG: Kein ngx.say() hier! Nutze ngx.log f√ºr Debugging.
                    if not res then
                        ngx.log(ngx.ERR, "Failed to request pusher: ", err)
                    else
                        ngx.log(ngx.INFO, "Pusher response status: ", res.status)
                    end
                end

                -- Warteschleife
                while true do
                    local is_blocked = shared:get("BLOCK:" .. path_segment)
                    if not is_blocked then break end

                    global_wait_count = global_wait_count + 1
                    local ok, err = global_gate_sem:wait(60)
                    global_wait_count = global_wait_count - 1

                    if not ok then
                        ngx.exit(ngx.HTTP_GATEWAY_TIMEOUT)
                    end
                end

                -- Zeitmessung setzen
                local end_time = ngx.now()
                local queue_duration = end_time - start_time

                ngx.var.queue_latency = string.format("%.4f", queue_duration)
                ngx.header["X-Queue-Latency"] = ngx.var.queue_latency
            }
            proxy_read_timeout 500s;
            proxy_connect_timeout 75s;
            proxy_send_timeout 500s;

            proxy_pass http://envoy:10000;
            proxy_http_version 1.1;
            proxy_set_header Host $host;
            proxy_set_header Connection "";
        }
        location /admin/list {
                                content_by_lua_block {
                                    local cjson = require("cjson")
                                    local shared = ngx.shared.gate_config

                                    local keys = shared:get_keys(1024)
                                    local blocked_list = {}

                                    for _, key in ipairs(keys) do
                                        local path = key:match("^BLOCK:(.*)")
                                        if path then
                                            table.insert(blocked_list, path)
                                        end
                                    end

                                    ngx.header.content_type = "application/json"
                                }
                    }
    }
}